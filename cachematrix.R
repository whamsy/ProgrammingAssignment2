## The basic outline of the two functions is that:
##   1. First, I define a function that can take a matrix as input and
##      create a matrix "instance" that incorporates functions for the matrix
##      in question. These functions can set the value of the matrix, get the
##      value of this matrix, set(cache) the value of its inverse and finally
##      get the inverse.
##   2. Next, I define a function to get the inverse of the matrix instance
##      defined above. It checks to see if the inverse has already been
##      calculated and cached. If yes, it returns the inverse. Else the inverse
##      is calculated and then cached.

## As outlined above, the makeCacheMatrix function takes a matrix as input
## and creates an instance of the matrix, returning a list of functions that
## can set the value of the matrix to the input given [using set()], return the
## value using the get() function, store the inverse to a cached variable "i" using
## the setinv() function and finally return this value when called using the getinv()
## function.

makeCacheMatrix <- function(x = matrix()) {

  i <- NULL
  set <- function(y) {
    x <<- y
    i <<- NULL
  }
  get <- function() x
  setinv <- function(inv) i <<- inv
  getinv <- function() i
  list(set = set, get = get,
       setinv = setinv,
       getinv = getinv)

}


## The cacheSolve function takes a matrix x as input which has to be an instance
## generated by the makeCacheMatrix function. The first step is to check if this
## instance already has the inverse value cached. To do this, it invokes the getinv()
## function of x. If the inverse has been cached a non-null value is returned and
## this is returned as the output. No further computation takes place. However in
## case the inverse is not found, the inverse is calculated using solve() and the
## setinv() function of x is invoked. This stores the inverse as a cached variable
## for future use.

cacheSolve <- function(x, ...) {

  i <- x$getinv()
  if(!is.null(i)) {
    message("getting cached data")
    return(i)
  }
  data <- x$get()
  i <- solve(data, ...)
  x$setinv(i)

  ## Returning i which is  inverse of 'x'
  i
}
